<!DOCTYPE html>
<!--
Copyright (C) 2025 KSEC - Erez Kalman. All Rights Reserved.

SPDX-License-Identifier: (AGPL-3.0-or-later OR LicenseRef-Erez_Kalman_KSEC-Commercial)

This source code is licensed under a dual-license model.
See the LICENSE, and LICENSE.AGPL.md files for full details.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navigation</title>
    <style>
        /* Basic styling for a clean look and for displaying messages */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            text-align: center;
            padding: 2em;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            color: #555;
        }
        pre {
            white-space: pre-wrap;       /* Since CSS 2.1 */
            white-space: -moz-pre-wrap;  /* Mozilla, since 1999 */
            white-space: -pre-wrap;      /* Opera 4-6 */
            white-space: -o-pre-wrap;    /* Opera 7 */
            word-wrap: break-word;       /* Internet Explorer 5.5+ */
            background-color: #eee;
            padding: 1em;
            border-radius: 4px;
            text-align: left;
            max-width: 80vw;
        }
        iframe {
            width: 100vw;
            height: 100vh;
            border: none;
        }
        img, video, audio {
           max-width: 100%;
           height: auto;
           display: block;
           margin: auto;
           background-color: #fff;
        }
    </style>
</head>
<body>
    <!-- This container is a placeholder while the script runs -->
    <div class="container">
        <h1>Loading...</h1>
    </div>

    <script>
    /**
     * -------------------------------------------------------------------------
     * SPA Redirector/Content Server (v3)
     * -------------------------------------------------------------------------
     * This script performs the following actions:
     *
     * 1. Checks URL for a parameter (e.g., ?folder=file or ?folder=file.html).
     * 2. If no parameter exists, it processes 'root.txt'.
     * 3. If a parameter is given WITHOUT a file extension (e.g., ?sfdc=1.0), it appends
     * '.txt' (sfdc/1.0.txt) and processes that file.
     * - If the .txt file's content is a URL, it redirects.
     * - Otherwise, the .txt file's content is treated as ANOTHER filename,
     * which is then fetched from the same folder and displayed.
     * 4. If a parameter is given WITH a file extension (e.g., ?sfdc=page.html), it serves
     * the file 'sfdc/page.html' directly.
     * 5. If any requested file is not found, it falls back to processing 'root.txt'.
     */

    document.addEventListener('DOMContentLoaded', main);

    /**
     * Main entry point function that runs on page load.
     */
    async function main() {
        try {
            const params = new URLSearchParams(window.location.search);
            const firstParam = params.entries().next().value;

            if (firstParam) {
                const [folder, file] = firstParam;
                
                // Basic sanitization to prevent path traversal
                if (folder.includes('/') || folder.includes('\\') || file.includes('/') || file.includes('\\')) {
                   throw new Error("Invalid characters in parameters.");
                }

                if (file.includes('.')) {
                    // Has an extension: serve the file directly
                    const filePath = `${folder}/${file}`;
                    await serveDirectly(filePath, false);
                } else {
                    // No extension: append .txt and parse for redirect/indirect serving
                    const filePath = `${folder}/${file}.txt`;
                    await processPointerFile(filePath, false);
                }
            } else {
                // No parameters, process the root file
                await processPointerFile('root.txt', true);
            }
        } catch (error) {
            console.error("Error in main execution:", error);
            displayMessage('Error', `An unexpected error occurred: ${error.message}`);
        }
    }

    /**
     * Processes a "pointer" file (.txt). It either contains a redirect URL
     * or points to another file to be served.
     * @param {string} path - The relative path to the .txt file.
     * @param {boolean} isRoot - True if this is the 'root.txt' file, used to prevent infinite fallback loops.
     */
    async function processPointerFile(path, isRoot) {
        try {
            const response = await fetch(path, { cache: 'no-store' });
            if (!response.ok) {
                throw new Error(`Pointer file not found: ${response.status}`);
            }

            const textContent = (await response.text()).trim();
            const firstLine = textContent.split('\n')[0].trim();

            if (firstLine.startsWith('http')) {
                // If it's a URL, redirect immediately.
                window.location.replace(firstLine);
            } else {
                // Otherwise, the content is a new filename. Serve that file.
                const directory = path.substring(0, path.lastIndexOf('/'));
                const newFilePath = directory ? `${directory}/${textContent}` : textContent;
                await serveDirectly(newFilePath, isRoot);
            }
        } catch (error) {
            console.warn(`Could not process pointer file at '${path}':`, error.message);
            // If the requested file failed AND it wasn't the root file, fall back to 'root.txt'.
            if (!isRoot) {
                console.log("Falling back to 'root.txt'.");
                await processPointerFile('root.txt', true);
            } else {
                displayMessage('Configuration Error', "The required 'root.txt' file (or the file it points to) is missing or could not be loaded.");
            }
        }
    }

    /**
     * Fetches and serves a file directly, inferring its MIME type from the extension.
     * @param {string} path - The relative path to the file to serve.
     * @param {boolean} isRootContext - True if the fallback should be a hard error.
     */
    async function serveDirectly(path, isRootContext) {
        try {
            const response = await fetch(path, { cache: 'no-store' });
            if (!response.ok) {
                throw new Error(`Target file not found: ${response.status}`);
            }
            const blob = await response.blob();
            const mimeType = getMimeTypeFromPath(path);
            displayContent(blob, mimeType);
        } catch (error) {
            console.warn(`Could not directly serve file at '${path}':`, error.message);
            if (!isRootContext) {
                console.log("Falling back to 'root.txt'.");
                await processPointerFile('root.txt', true);
            } else {
                 displayMessage('Configuration Error', `The file '${path}' specified by root.txt is missing or could not be loaded.`);
            }
        }
    }

    /**
     * Renders the content to the screen.
     * @param {string|Blob} content - The file content to display.
     * @param {string} mimeType - The MIME type of the content.
     */
    function displayContent(content, mimeType) {
        const blob = content instanceof Blob ? content : new Blob([content], { type: mimeType });
        
        document.body.innerHTML = '';
        document.body.style.margin = '0';

        if (mimeType.startsWith('text/html')) {
            const iframe = document.createElement('iframe');
            iframe.src = URL.createObjectURL(blob);
            document.body.appendChild(iframe);
        } else if (mimeType.startsWith('image/') || mimeType.startsWith('video/') || mimeType.startsWith('audio/') || mimeType === 'application/pdf') {
            const url = URL.createObjectURL(blob);
            let element;
            if (mimeType === 'application/pdf') {
                element = document.createElement('iframe');
            } else if (mimeType.startsWith('image/')) {
                element = document.createElement('img');
            } else {
                element = document.createElement(mimeType.split('/')[0]);
                element.controls = true;
            }
            element.src = url;
            document.body.appendChild(element);
        } else {
            const pre = document.createElement('pre');
            const reader = new FileReader();
            reader.onload = function() {
                pre.textContent = reader.result;
            };
            reader.readAsText(blob);
            document.body.style.margin = '1em';
            document.body.appendChild(pre);
        }
    }

    /**
     * A helper function to display a formatted message to the user.
     * @param {string} title - The title of the message.
     * @param {string} message - The HTML-formatted message body.
     */
    function displayMessage(title, message) {
        document.body.innerHTML = `
            <div class="container">
                <h1>${title}</h1>
                <p>${message}</p>
            </div>`;
    }

    /**
     * Infers a MIME type from a file extension.
     * @param {string} path - The file path or name.
     * @returns {string} The inferred MIME type or a default.
     */
    function getMimeTypeFromPath(path) {
        const extension = path.split('.').pop().toLowerCase();
        const mimeTypes = {
            'txt': 'text/plain',
            'html': 'text/html',
            'css': 'text/css',
            'js': 'application/javascript',
            'json': 'application/json',
            'xml': 'application/xml',
            'png': 'image/png',
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg',
            'gif': 'image/gif',
            'svg': 'image/svg+xml',
            'mp4': 'video/mp4',
            'webm': 'video/webm',
            'mp3': 'audio/mpeg',
            'wav': 'audio/wav',
            'pdf': 'application/pdf',
        };
        return mimeTypes[extension] || 'application/octet-stream';
    }

    </script>
</body>
</html>
